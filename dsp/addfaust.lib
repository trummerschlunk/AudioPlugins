declare name "addfaust.lib";
declare version "1.0";
declare author "Faust";
declare license "GPL3";

import("stdfaust.lib");

// usage
// add = library("addfaust.lib");
// add.peak_expansio...



//--------------------`(co.)peak_expansion_gain_N_chan_db`-------------------
// N channels dynamic range expander gain computer.
// `peak_expansion_gain_N_chan_db` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : peak_expansion_gain_N_chan_db(strength,thresh,range,att,hold,rel,knee,prePost,link,maxHold,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the expansion (0 = no expansion, 100 means gating, <1 means upward compression)
// * `thresh`: dB level threshold below which expansion kicks in
// * `range`: maximum amount of expansion in dB
// * `att`: attack time = time constant (sec) coming out of expansion
// * `hold` : hold time (sec)
// * `rel`: release time = time constant (sec) going into expansion
// * `knee`: a gradual increase in gain reduction around the threshold:
// above thresh+(knee/2) there is no gain reduction,
// below thresh-(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-range detector
// * `link`: the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `maxHold`: the maximum hold time in samples, known at compile time
// * `N`: the number of channels of the gain computer, known at compile time
//
//------------------------------------------------------------

declare peak_expansion_gain_N_chan_db author "Bart Brouns";
declare peak_expansion_gain_N_chan_db license "GPLv3";

// generalise expansion gains for N channels.
// first we define a mono version:
peak_expansion_gain_N_chan_db(strength,thresh,range,att,hold,rel,knee,prePost,link,maxHold,1) =
  peak_expansion_gain_mono_db(maxHold,strength,thresh,range,att,hold,rel,knee,prePost);

// The actual N-channels version:
// Calculate the maximum gain reduction of N channels,
// and then crossfade between that and each channel's own gain reduction,
// to link/unlink channels
peak_expansion_gain_N_chan_db(strength,thresh,range,att,hold,rel,knee,prePost,link,maxHold,N) =
  par(i, N, peak_expansion_gain_mono_db(maxHold,strength,thresh,range,att,hold,rel,knee,prePost))

  <: (si.bus(N),(ba.parallelMax(N) <: si.bus(N))) : ro.interleave(N,2) : par(i,N,(it.interpolate_linear(link)));


peak_expansion_gain_mono_db(maxHold,strength,thresh,range,attack,hold,release,knee,prePost) =
  level(hold,maxHold):ba.bypass1(prePost,si.lag_ud(attack,release)) :ba.linear2db : gain_computer(strength,thresh,range,knee) : ba.bypass1((prePost !=1),si.lag_ud(att,rel))
with {
  gain_computer(strength,thresh,range,knee,level) =
    (select3((level>(thresh-(knee/2)))+(level>(thresh+(knee/2)))
             , (level-thresh)
             , ((level-thresh-(knee/2)):pow(2) /(min(ma.EPSILON,knee*-2)))
             , 0
             ) *abs(strength):max(range) * (-1+(2*(strength>0)))
    );
  att = select2((strength>0),release,attack);
  rel = select2((strength>0),attack,release);
  level(hold,maxHold,x) = x : abs : ba.slidingMax(hold*ma.SR,maxHold);
};


//--------------------`(co.)expander_N_chan`-------------------
// Feed forward N channels dynamic range expander.
// `expander_N_chan` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : expander_N_chan(strength,thresh,range,att,hold,rel,knee,prePost,link,meter,maxHold,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the expansion (0 = no expansion, 100 means gating, <1 means upward compression)
// * `thresh`: dB level threshold below which expansion kicks in
// * `range`: maximum amount of expansion in dB
// * `att`: attack time = time constant (sec) coming out of expansion
// * `hold` : hold time
// * `rel`: release time = time constant (sec) going into expansion
// * `knee`: a gradual increase in gain reduction around the threshold:
// above thresh+(knee/2) there is no gain reduction,
// below thresh-(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-range detector
// * `link`: the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `meter`: a gain reduction meter. It can be implemented like so:
// `meter = _<:(_, (ba.linear2db:max(maxGR):meter_group((hbargraph("[1][unit:dB][tooltip: gain reduction in dB]", maxGR, 0))))):attach;`
// * `maxHold`: the maximum hold time in samples, known at compile time
// * `N`: the number of channels of the expander, known at compile time
//
//------------------------------------------------------------

declare expander_N_chan author "Bart Brouns";
declare expander_N_chan license "GPLv3";

// Feed forward expander
expander_N_chan(strength,thresh,range,att,hold,rel,knee,prePost,link,meter,maxHold,N) =
  expanderSC_N_chan(strength,thresh,range,att,hold,rel,knee,prePost,link,meter,maxHold,N,_,0,0);

//--------------------`(co.)expanderSC_N_chan`-------------------
// Feed forward N channels dynamic range expander with sidechain.
// `expanderSC_N_chan` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : expanderSC_N_chan(strength,thresh,range,att,hold,rel,knee,prePost,link,meter,maxHold,N,SCfunction,SCswitch,SCsignal) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the expansion (0 = no expansion, 100 means gating, <1 means upward compression)
// * `thresh`: dB level threshold below which expansion kicks in
// * `range`: maximum amount of expansion in dB
// * `att`: attack time = time constant (sec) coming out of expansion
// * `hold` : hold time
// * `rel`: release time = time constant (sec) going into expansion
// * `knee`: a gradual increase in gain reduction around the threshold:
// above thresh+(knee/2) there is no gain reduction,
// below thresh-(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-range detector
// * `link`: the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `meter`: a gain reduction meter. It can be implemented like so:
// `meter = _<:(_, (ba.linear2db:max(maxGR):meter_group((hbargraph("[1][unit:dB][tooltip: gain reduction in dB]", maxGR, 0))))):attach;`
// * `maxHold`: the maximum hold time in samples, known at compile time
// * `N`: the number of channels of the expander, known at compile time
// * `SCfunction` : a function that get's placed before the level-detector, needs to have a single input and output
// * `SCswitch` : use either the regular audio input or the SCsignal as the input for the level detector
// * `SCsignal` : an audio signal, to be used as the input for the level detector when SCswitch is 1
//
//------------------------------------------------------------

declare expanderSC_N_chan author "Bart Brouns";
declare expanderSC_N_chan license "GPLv3";

// Feed forward expander with sidechain
expanderSC_N_chan(strength,thresh,range,att,hold,rel,knee,prePost,link,meter,maxHold,N,SCfunction,SCswitch,SCsignal) =
  si.bus(N) <:
  ((par(i, N, select2(SCswitch,_,SCsignal):SCfunction)
    : peak_expansion_gain_N_chan_db(strength,thresh,range,att,hold,rel,knee,prePost,link,maxHold,N))
  ,si.bus(N))
  : ro.interleave(N,2)
  : par(i,N,(meter:ba.db2linear)*_);

















//--------------------`(co.)peak_compression_gain_mono_db`-------------------
// Mono dynamic range compressor gain computer with dB output.
// `peak_compression_gain_mono_db` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : peak_compression_gain_mono_db(strength,thresh,att,rel,knee,prePost) : _
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log domain return-to-threshold detector
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design,
// A Tutorial and Analysis,
// Dimitrios GIANNOULIS (<Dimitrios.Giannoulis@eecs.qmul.ac.uk>),
// Michael MASSBERG (<michael@massberg.org>),
// and Josuah D.REISS (<josh.reiss@eecs.qmul.ac.uk>)
//------------------------------------------------------------

declare peak_compression_gain_mono_db author "Bart Brouns";
declare peak_compression_gain_mono_db license "GPLv3";

peak_compression_gain_mono_db(strength,thresh,att,rel,knee,prePost) =
  abs : ba.bypass1(prePost,si.onePoleSwitching(att,rel)) : ba.linear2db : gain_computer(strength,thresh,knee) : ba.bypass1((prePost !=1),si.onePoleSwitching(rel,att))
with {
  gain_computer(strength,thresh,knee,level) =
    select3((level>(thresh-(knee/2)))+(level>(thresh+(knee/2))),
            0,
            ((level-thresh+(knee/2)) : pow(2)/(2*max(ma.EPSILON,knee))),
            (level-thresh))
    : max(0)*-strength;
};


//--------------------`(co.)peak_compression_gain_N_chan_db`-------------------
// N channels dynamic range compressor gain computer with dB output.
// `peak_compression_gain_N_chan_db` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : peak_compression_gain_N_chan_db(strength,thresh,att,rel,knee,prePost,link,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-threshold detector
// * `link`: the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `N`: the number of channels of the compressor, known at compile time
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design,
// A Tutorial and Analysis,
// Dimitrios GIANNOULIS (<Dimitrios.Giannoulis@eecs.qmul.ac.uk>),
// Michael MASSBERG (<michael@massberg.org>),
// and Josuah D.REISS (<josh.reiss@eecs.qmul.ac.uk>)
//------------------------------------------------------------

declare peak_compression_gain_N_chan_db author "Bart Brouns";
declare peak_compression_gain_N_chan_db license "GPLv3";

// generalise compression gains for N channels.
// first we define a mono version:
peak_compression_gain_N_chan_db(strength,thresh,att,rel,knee,prePost,link,1) =
  peak_compression_gain_mono_db(strength,thresh,att,rel,knee,prePost);

// The actual N-channels version:
// Calculate the maximum gain reduction of N channels,
// and then crossfade between that and each channel's own gain reduction,
// to link/unlink channels
peak_compression_gain_N_chan_db(strength,thresh,att,rel,knee,prePost,link,N) =
  par(i, N, peak_compression_gain_mono_db(strength,thresh,att,rel,knee,prePost))
  <: (si.bus(N),(ba.parallelMin(N) <: si.bus(N))) : ro.interleave(N,2) : par(i,N,(it.interpolate_linear(link)));












//=====================================Mixing=============================================
//========================================================================================

// Implementation to share common code
dwmEnv(wetAmount, FX) = environment
{
    N = inputs(FX);
    wet(wg) = FX : par(i, N, *(wg));
    dry(dg) = par(i, N, *(dg));
    out(wg, dg) = si.bus(N) <: wet(wg), dry(dg) :> si.bus(N);
    
    dryWetMixer = out(wetGain, dryGain) 
    with { 
        wetGain = wetAmount; 
        dryGain = 1. - wetGain; 
    };
    
    dryWetMixerConstantPower = out(wetGain, dryGain)  
    with {
        theta = ma.PI*wetAmount/2.;
        dryGain = cos(theta)/sqrt(2.);
        wetGain = sin(theta)/sqrt(2.);
    };
};


//---------------`(ef.)dryWetMixer`-------------
// Linear dry-wet mixer for a N inputs and N outputs effect.
//
// #### Usage
//
// ```
// si.bus(inputs(FX)) : dryWetMixer(wetAmount, FX) : si.bus(inputs(FX))
// ```
//
// Where:
//
// * `wetAmount`: the wet amount (0-1). 0 produces only the dry signal and 1 produces only the wet signal
// * `FX`: an arbitrary effect (N inputs and N outputs) to apply to the input bus
//------------------------------------------------------------
declare dryWetMixer author "David Braun, revised by Stéphane Letz";

dryWetMixer(wetAmount, FX) = dwmEnv(wetAmount, FX).dryWetMixer;


//---------------`(ef.)dryWetMixerConstantPower`-------------
// Constant-power dry-wet mixer for a N inputs and N outputs effect.
//
// #### Usage
//
// ```
// si.bus(inputs(FX)) : dryWetMixerConstantPower(wetAmount, FX) :si.bus(inputs(FX))
// ```
//
// Where:
//
// * `wetAmount`: the wet amount (0-1). 0 produces only the dry signal and 1 produces only the wet signal
// * `FX`: an arbitrary effect (N inputs and N outputs) to apply to the input bus
//------------------------------------------------------------
declare dryWetMixerConstantPower author "David Braun, revised by Stéphane Letz";

dryWetMixerConstantPower(wetAmount, FX) = dwmEnv(wetAmount, FX).dryWetMixerConstantPower;














//################################ aanl.lib ##########################################
// A library for antialiased nonlinearities. Its official prefix is `aa`. 
//
// This library provides aliasing-suppressed nonlinearities through first-order 
// and second-order approximations of continuous-time signals, functions,
// and convolution based on antiderivatives. This technique is particularly 
// effective if combined with low-factor oversampling, for example, operating
// at 96 kHz or 192 kHz sample-rate.
//
// The library contains trigonometric functions as well as other nonlinear 
// functions such as bounded and unbounded saturators.
//
// Due to their limited domains or ranges, some of these functions may not 
// suitable for audio nonlinear processing or waveshaping, although
// they have been included for completeness. Some other functions,
// for example, tan() and tanh(), are only available with first-order
// antialiasing due to the complexity of the antiderivative of the 
// x * f(x) term, particularly because of the necessity of the dilogarithm 
// function, which requires special implementation.
//
// Future improvements to this library may include an adaptive
// mechanism to set the ill-conditioned cases threshold to improve
// performance in varying cases.
//
// Note that the antialiasing functions introduce a delay in the path,
// respectively half and one-sample delay for first and second-order functions.
//
// Also note that due to division by differences, it is vital to use
// double-precision or more to reduce errors.
//
// The environment identifier for this library is `aa`. After importing
// the standard libraries in Faust, the functions below can be called as `aa.function_name`.
// 
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/aanl.lib>
// * Reducing the Aliasing in Nonlinear Waveshaping Using Continuous-time Convolution,
// Julian Parker, Vadim Zavalishin, Efflam Le Bivic, DAFX, 2016
// * <http://dafx16.vutbr.cz/dafxpapers/20-DAFx-16_paper_41-PN.pdf>
//########################################################################################

ba = library("basics.lib");
ma = library("maths.lib");

declare name "Faust Antialiased Nonlinearities";
declare version "1.4.2";

//==============================Auxiliary Functions=======================================
//========================================================================================

//-------`(aa.)clip`-----------
// Clipping function.
//-----------------------------
clip(l, h, x) = max(l, min(h, x));


//-------`(aa.)Rsqrt`----------
// Real-valued sqrt().
//-----------------------------
Rsqrt(x) = sqrt(max(0.0, x));


//-------`(aa.)Rlog`-----------
// Real-valued log().
//-----------------------------
Rlog(x) = log(max(ma.EPSILON, x));


//-------`(aa.)Rtan`-----------
// Real-valued tan().
//-----------------------------
Rtan(x) = tan(clip(0-ma.MAX, ma.MAX, x));


//-------`(aa.)Racos`----------
// Real-valued acos().
//-----------------------------
Racos(x) = acos(clip(-1.0, 1.0, x));


//-------`(aa.)Rasin`----------
// Real-valued asin().
//-----------------------------
Rasin(x) = asin(clip(-1.0, 1.0, x));


//-------`(aa.)Racosh`----------
// Real-valued acosh()
//------------------------------
Racosh(x) = ma.acosh(clip(1.0, ma.MAX, x));


//-------`(aa.)Rcosh`----------
// Real-valued cosh().
//-----------------------------
Rcosh(x) = min(ma.MAX, ma.cosh(x));


//-------`(aa.)Rsinh`-----------
// Real-valued sinh().
//------------------------------
Rsinh(x) = clip(0-ma.MAX, ma.MAX, ma.sinh(x));


//-------`(aa.)Ratanh`----------
// Real-valued atanh().
//------------------------------
Ratanh(x) = ma.atanh(clip(-1.0 + ma.EPSILON, 1.0 - ma.EPSILON, x));


//-------`(aa.)ADAA1`---------------------
// Generalised first-order Antiderivative Anti-Aliasing (ADAA) function.
//
// Implements a first-order ADAA approximation to reduce aliasing
// in nonlinear audio processing.
// 
// #### Usage
//
// ```
// _ : ADAA1(EPS, f, F1) : _
// ```
// 
// Where:
//
// * `EPS`: a threshold for switching between safe and ill-conditioned paths
// * `f`: a function that we want to process with ADAA
// * `F1`: f's first antiderivative

declare ADAA1 author "Dario Sanfilippo";
declare ADAA1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare ADAA1 license "MIT License";
ADAA1(EPS, f, F1, x) = D1q 
      with {
           D1q = ba.if(abs(x - x') <= EPS, ill_D1q, safe_D1q)
               with {
                   ill_D1q = f(x_m);
                   safe_D1q = (F1(x) - F1(x')) / (x - x');
                   x_m = .5 * (x + x');
               };
      };


//-------`(aa.)ADAA2`---------------------
// Generalised second-order Antiderivative Anti-Aliasing (ADAA) function.
//
// Implements a second-order ADAA approximation for even better aliasing reduction
// at the cost of additional computation.

// #### Usage
//
// ```
// _ : ADAA2(EPS, f, F1, F2) : _
// ```
//
// Where:
//
// * `EPS`: a threshold for switching between safe and ill-conditioned paths
// * `f`: a function that we want to process with ADAA
// * `F1`: f's first antiderivative
// * `F2`: f's second antiderivative

declare ADAA2 author "Dario Sanfilippo";
declare ADAA2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare ADAA2 license "MIT License";
ADAA2(EPS, f, F1, F2, x) = T1 + T2 
      with {
           T1 = ba.if((x - x') ^ 2.0 <= EPS, ill_T1, safe_T1)
               with {
                   ill_T1 = .5 * f((x + 2.0 * x') / 3.0);
                   safe_T1 = (x * (F1(x) - F1(x')) - (F2(x) - F2(x'))) /
                       ((x - x') ^ 2.0);
               };
           T2 = ba.if((x' - x'') ^ 2.0 <= EPS, ill_T2, safe_T2)
               with {
                   ill_T2 = .5 * f((x'' + 2.0 * x') / 3.0);
                   safe_T2 = (x'' * (F1(x'') - F1(x')) - (F2(x'') - F2(x'))) /
                       ((x'' - x') ^ 2.0);
               };
      };


//==============================Main functions============================================
//========================================================================================

//================= Saturators ===============
//
// These antialiased saturators perform best with high-amplitude input
// signals. If the input is only slightly saturated, hence producing
// negligible aliasing, the trivial saturator may result in a better
// overall output, as noise can be introduced by first and second ADAA
// at low amplitudes. 
//
// Once determining the lowest saturation level for which the antialiased 
// functions perform adequately, it might be sensible to cross-fade
// between the trivial and the antialiased saturators according to the
// amplitude profile of the input signal.
//==============================================

//-------`(aa.)hardclip`---------------------
//
// First-order ADAA hard-clip.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.hardclip : _
// ```
//---------------------------------------------
declare hardclip author "Dario Sanfilippo";
declare hardclip copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare hardclip license "MIT License";
hardclip(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001;
           f(x_f) = clip(-1.0, 1.0, x_f);
           F1(x_F1) = ba.if(   (x_F1 <= 1.0) & (x_F1 >= -1.0), 
                               .5 * x_F1 ^ 2.0, 
                               x_F1 * ma.signum(x_F1) - .5);
      };


//-------`(aa.)hardclip2`---------------------
//
// Second-order ADAA hard-clip.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.hardclip2 : _
// ```
//---------------------------------------------
declare hardclip2 author "Dario Sanfilippo";
declare hardclip2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare hardclip2 license "MIT License";
hardclip2(x) = ADAA2(EPS, f, F1, F2, x) 
      with {
           EPS = .001;
           f(x_f) = clip(-1.0, 1.0, x_f);
           F1(x_F1) = ba.if(   (x_F1 <= 1.0) & (x_F1 >= -1.0), 
                               .5 * x_F1 ^ 2.0, 
                               x_F1 * ma.signum(x_F1) - .5);
           F2(x_F2) = ba.if(   (x_F2 <= 1.0) & (x_F2 >= -1.0), 
                               (1.0 / 3.0) * x_F2 ^ 3.0, 
                               ((.5 * x_F2 ^ 2.0) - 1.0 / 6.0) * 
                                   ma.signum(x_F2));
      };


//-------`(aa.)cubic1`---------------------
//
// First-order ADAA cubic saturator.
//
// The domain of this function is ℝ; its theoretical range is 
// [-2.0/3.0; 2.0/3.0].
//
// #### Usage
// ```
// _ : aa.cubic1 : _
// ```
//-------------------------------------------
declare cubic1 author "Dario Sanfilippo";
declare cubic1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cubic1 license "MIT License";
cubic1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001; 
           f(x_f) = ba.if( (x_f < 1.0) & (x_f > -1.0), 
                           x_f - x_f ^ 3.0 / 3.0, 
                           (2.0 / 3.0) * ma.signum(x_f));
           F1(x_F1) = ba.if(   x_F1 <= -1.0,
                               x_F1 * -2.0 / 3.0,
                               ba.if(  x_F1 >= 1.0,
                                       x_F1 * 2.0 / 3.0,
                                       x_F1 ^ 2.0 / 2.0 - x_F1 ^ 4.0 / 12.0));
      };


//-------`(aa.)parabolic`---------------------
//
// First-order ADAA parabolic saturator.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.parabolic : _
// ```
//--------------------------------------------
declare parabolic author "Dario Sanfilippo";
declare parabolic copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare parabolic license "MIT License";
parabolic(x) = ADAA1(EPS, f, F1, x) 
      with {
           EPS = .001; 
           f(x_f) = ba.if( abs(x_f) <= 2.0, 
                           x_f * (1.0 - abs(x_f) / 4.0), 
                           ma.signum(x_f));
           F1(x_F1) = ba.if(   abs(x_F1) <= 2.0, 
                               (-1.0 / 12.0) * x_F1 ^ 2.0 * 
                                   (x_F1 * ma.signum(x_F1) - 6.0),
                               abs(x_F1));
      };


//-------`(aa.)parabolic2`---------------------
//
// Second-order ADAA parabolic saturator.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.parabolic : _
// ```
//---------------------------------------------
declare parabolic2 author "Dario Sanfilippo";
declare parabolic2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare parabolic2 license "MIT License";
parabolic2(x) = ADAA2(EPS, f, F1, F2, x) 
      with {
           EPS = .001; 
           f(x_f) = ba.if( abs(x_f) <= 2.0,
                           x_f * (1.0 - abs(x_f) / 4.0),
                           ma.signum(x_f));
           F1(x_F1) = ba.if(   abs(x_F1) <= 2.0,
                               (-1.0 / 12.0) * x_F1 ^ 2.0 * 
                                   (x_F1 * ma.signum(x_F1) - 6.0),
                               abs(x_F1));
           F2(x_F2) = ba.if(   abs(x_F2) <= 2.0,
                               (1.0 / 48.0) * x_F2 ^ 3.0 * 
                                   (16.0 - 3.0 * x_F2 * ma.signum(x_F2)),
                               .5 * x_F2 ^ 2.0 * ma.signum(x_F2));
      };


//-------`(aa.)hyperbolic`---------------------
//
// First-order ADAA hyperbolic saturator.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.hyperbolic : _
// ```
//---------------------------------------------
declare hyperbolic author "Dario Sanfilippo";
declare hyperbolic copyright "Copyright (C) 2021 Dario Sanfilippo
     <sanfilippo.dario@gmail.com>";
declare hyperbolic license "MIT License";
hyperbolic(x) = ADAA1(EPS, f, F1, x)
    with {
        EPS = .001; 
        f(x_f) = x_f / (1.0 + abs(x_f));
        F1(x_F1) = abs(x_F1) - log(1.0 + abs(x_F1));
    };


//-------`(aa.)hyperbolic2`---------------------
//
// Second-order ADAA hyperbolic saturator.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.hyperbolic2 : _
// ```
//----------------------------------------------
declare hyperbolic2 author "Dario Sanfilippo";
declare hyperbolic2 copyright "Copyright (C) 2021 Dario Sanfilippo
     <sanfilippo.dario@gmail.com>";
declare hyperbolic2 license "MIT License";
hyperbolic2(x) = ADAA2(EPS, f, F1, F2, x)
    with {
        EPS = .001; 
        f(x_f) = x_f / (1.0 + abs(x_f));
        F1(x_F1) = abs(x_F1) - log(1.0 + abs(x_F1));
        F2(x_F2) = ma.signum(x_F2) * (.5 * (3.0 - 2.0 * abs(x_F2) + x_F2 ^ 2.0 + 
            2.0 * log(1.0 + abs(x_F2))) - 3.0 / 2.0) + 3.0 / 2.0;
    };


//-------`(aa.)sinarctan`---------------------
//
// First-order ADAA sin(atan()) saturator.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.sinatan : _
// ```
//----------------------------------------------
declare sinarctan author "Dario Sanfilippo";
declare sinarctan copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sinarctan license "MIT License";
sinarctan(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001; 
           f(x_f) = x_f / sqrt(1.0 + x_f ^ 2.0);
           F1(x_F1) = sqrt(x_F1 ^ 2.0 + 1.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
      };


//-------`(aa.)sinarctan2`---------------------
//
// Second-order ADAA sin(atan()) saturator.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.sinarctan2 : _
// ```
//----------------------------------------------
declare sinarctan2 author "Dario Sanfilippo";
declare sinarctan2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sinarctan2 license "MIT License";
sinarctan2(x) = ADAA2(EPS, f, F1, F2, x) 
      with {
           EPS = .001; 
           f(x_f) = x_f / sqrt(1.0 + x_f ^ 2.0);
           F1(x_F1) = sqrt(x_F1 ^ 2.0 + 1.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .5 * x_F2 * sqrt(x_F2 ^ 2.0 + 1.0) - .5 * ma.asinh(x_F2);
      };


softclipEnv = environment {
    // this non anti-aliased version exists in misceffects.lib
    softclip(x) = ba.ifNcNo(2, 1, 
        absX < 1/3, 2*x,
        absX < 2/3, ma.signum(x)*(3-(2-absX*3)^2)/3,
        ma.signum(x)
        )
    with {
        s = ba.if(x>0, 1, -1); // faster than ma.signum(x)
        absX = abs(x);
    };
    EPS = .001; 

    F1(x) = ba.ifNcNo(2, 1,
        absX < 1/3, x^2,
        absX < 2/3, -1.*absX/3+2*x^2-absX^3+1/27,
        absX - 7/27
    )
    with {
        absX = abs(x);
    };

    F2(x) = ba.ifNcNo(2, 1,
        absX < 1/3, (2/3)*(x^3),
        absX < 2/3, s*((-1/6)*(x^2)-(3/4)*(x^4)+1/324) + (4/3)*(x^3),
        s*((0.5)*(x^2) - 5/108)
    )
    with {
        s = ba.if(x>0, 1, -1); // faster than ma.signum(x)
        absX = abs(x);
    };

    softclipQuadratic1 = ADAA1(EPS, softclip, F1);
    softclipQuadratic2 = ADAA2(EPS, softclip, F1, F2);
};


//-------`(aa.)softclipQuadratic1`---------------------
//
// First-order ADAA quadratic softclip.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.softclipQuadratic1 : _
// ```
//----------------------------------------------
declare softclipQuadratic1 author "David Braun";
declare softclipQuadratic1 copyright "Copyright (C) 2024 David Braun";
declare softclipQuadratic1 license "MIT license";

softclipQuadratic1 = softclipEnv.softclipQuadratic1;


//-------`(aa.)softclipQuadratic2`---------------------
//
// Second-order ADAA quadratic softclip.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.softclipQuadratic2 : _
// ```
//----------------------------------------------
declare softclipQuadratic2 author "David Braun";
declare softclipQuadratic2 copyright "Copyright (C) 2024 David Braun";
declare softclipQuadratic2 license "MIT license";

softclipQuadratic2 = softclipEnv.softclipQuadratic2;


//-------`(aa.)tanh1`---------------------
//
// First-order ADAA tanh() saturator.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.tanh1 : _
// ```
//----------------------------------------------
declare tanh1 author "Dario Sanfilippo";
declare tanh1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare tanh1 license "MIT License";
tanh1(x) = ADAA1(EPS, f, F1, x) 
      with {
           EPS = .001; 
           f(x_f) = ma.tanh(x_f);
           F1(x_F1) = log(Rcosh(x_F1));
      };


//-------`(aa.)arctan`---------------------
//
// First-order ADAA atan().
//
// The domain of this function is ℝ; its theoretical range is [-π/2.0; π/2.0].
//
// #### Usage
// ```
// _ : aa.arctan : _
// ```
//-------------------------------------------
declare arctan author "Dario Sanfilippo";
declare arctan copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arctan license "MIT License";
arctan(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001; 
           f(x_f) = atan(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - .5 * log(x_F1 ^ 2.0 + 1.0);
      };


//-------`(aa.)arctan2`---------------------
//
// Second-order ADAA atan().
//
// The domain of this function is ℝ; its theoretical range is ]-π/2.0; π/2.0[.
//
// #### Usage
// ```
// _ : aa.arctan2 : _
// ```
//-------------------------------------------
declare arctan2 author "Dario Sanfilippo";
declare arctan2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arctan2 license "MIT License";
arctan2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = .001; 
           f(x_f) = atan(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - .5 * log(x_F1 ^ 2.0 + 1.0);
           F2(x_F2) = .5 * x_F2 ^ 2.0 * f(x_F2) - x_F2 / 2.0 + .5 * f(x_F2);
      };


//-------`(aa.)asinh1`---------------------
//
// First-order ADAA asinh() saturator (unbounded).
//
// The domain of this function is ℝ; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.asinh1 : _
// ```
//-------------------------------------------
declare asinh1 author "Dario Sanfilippo";
declare asinh1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare asinh1 license "MIT License";
asinh1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001; 
           f(x_f) = ma.asinh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - sqrt(1.0 + x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
      };


//-------`(aa.)asinh2`---------------------
//
// Second-order ADAA asinh() saturator (unbounded).
//
// The domain of this function is ℝ; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.asinh2 : _
// ```
//-------------------------------------------
declare asinh2 author "Dario Sanfilippo";
declare asinh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare asinh2 license "MIT License";
asinh2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = .001; 
           f(x_f) = ma.asinh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - sqrt(1.0 + x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .25 * (2.0 * x_F2 ^ 2.0 * f(x_F2) + f(x_F2) - 
               sqrt(x_F2 ^ 2.0 + 1.0) * x_F2);
      };


//================= Trigonometry ===============
// These functions are reliable if input signals are within their domains.
//============================================


//-------`(aa.)cosine1`---------------------
//
// First-order ADAA cos().
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.cosine1 : _
// ```
//-------------------------------------------
declare cosine1 author "Dario Sanfilippo";
declare cosine1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cosine1 license "MIT License";
cosine1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001; 
           f(x_f) = cos(x_f);
           F1(x_F1) = sin(x_F1);
      };


//-------`(aa.)cosine2`---------------------
//
// Second-order ADAA cos().
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.cosine2 : _
// ```
//-------------------------------------------
declare cosine2 author "Dario Sanfilippo";
declare cosine2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cosine2 license "MIT License";
cosine2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = .001; 
           f(x_f) = cos(x_f);
           F1(x_F1) = sin(x_F1);
           F2(x_F2) = x_F2 * sin(x_F2) + cos(x_F2);
      };


//-------`(aa.)arccos`---------------------
//
// First-order ADAA acos().
//
// The domain of this function is [-1.0; 1.0]; its theoretical range is
// [π; 0.0].
//
// #### Usage
// ```
// _ : aa.arccos : _
// ```
//------------------------------------------
declare arccos author "Dario Sanfilippo";
declare arccos copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arccos license "MIT License";
arccos(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001; 
           f(x_f) = Racos(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
      };


//-------`(aa.)arccos2`---------------------
//
// Second-order ADAA acos().
//
// The domain of this function is [-1.0; 1.0]; its theoretical range is 
// [π; 0.0].
//
// Note that this function is not accurate for low-amplitude or low-frequency 
// input signals. In that case, the first-order ADAA arccos() can be used.
//
// #### Usage
// ```
// _ : aa.arccos2 : _
// ```
//--------------------------------------------
declare arccos2 author "Dario Sanfilippo";
declare arccos2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arccos2 license "MIT License";
arccos2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = .001; 
           f(x_f) = Racos(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .25 * (2.0 * x_F2 ^ 2.0 * f(x_F2) + Rasin(x_F2) -
               Rsqrt(1.0 - x_F2 ^ 2.0));
      };


//-------`(aa.)acosh1`---------------------
//
// First-order ADAA acosh(). 
//
// The domain of this function is ℝ >= 1.0; its theoretical range is ℝ >= 0.0.
//
// #### Usage
// ```
// _ : aa.acosh1 : _
// ```
//------------------------------------------
declare acosh1 author "Dario Sanfilippo";
declare acosh1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare acosh1 license "MIT License";
acosh1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001; 
           f(x_f) = Racosh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(x_F1 - 1.0) * Rsqrt(x_F1 + 1.0);
      };


//-------`(aa.)acosh2`---------------------
//
// Second-order ADAA acosh().
//
// The domain of this function is ℝ >= 1.0; its theoretical range is ℝ >= 0.0.
//
// Note that this function is not accurate for low-frequency input signals. 
// In that case, the first-order ADAA acosh() can be used.
//
// #### Usage
// ```
// _ : aa.acosh2 : _
// ```
//-------------------------------------------
declare acosh2 author "Dario Sanfilippo";
declare acosh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare acosh2 license "MIT License";
acosh2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = .001;
           f(x_f) = Racosh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(x_F1 - 1.0) * Rsqrt(x_F1 + 1.0);
           F2(x_F2) = .5 * x_F2 ^ 2.0 * f(x_F2) - .25 * 
               Rsqrt(x_F2 - 1.0) * Rsqrt(x_F2 + 1.0) * x_F2 -
                   .25 * Rlog(x_F2 + Rsqrt(x_F2 - 1.0) * Rsqrt(x_F2 + 1.0));
      };


//-------`(aa.)sine`---------------------
//
// First-order ADAA sin().
//
// The domain of this function is ℝ; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.sine : _
// ```
//----------------------------------------
declare sine author "Dario Sanfilippo";
declare sine copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sine license "MIT License";
sine(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001;
           f(x_f) = sin(x_f);
           F1(x_F1) = -1.0 * cos(x_F1);
      };


//-------`(aa.)sine2`---------------------
//
// Second-order ADAA sin().
//
// The domain of this function is ℝ; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.sine2 : _
// ```
//----------------------------------------
declare sine2 author "Dario Sanfilippo";
declare sine2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sine2 license "MIT License";
sine2(x) = ADAA2(EPS, f, F1, F2, x) 
      with {
           EPS = .001;
           f(x_f) = sin(x_f);
           F1(x_F1) = 1.0 - cos(x_F1);
           F2(x_F2) = sin(x_F2) - x_F2 * cos(x_F2);
      };


//-------`(aa.)arcsin`---------------------
//
// First-order ADAA asin().
//
// The domain of this function is [-1.0, 1.0]; its theoretical range is 
// [-π/2.0; π/2.0].
//
// #### Usage
// ```
// _ : aa.arcsin : _
// ```
//------------------------------------------
declare arcsin author "Dario Sanfilippo";
declare arcsin copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arcsin license "MIT License";
arcsin(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001;
           f(x_f) = Rasin(x_f);
           F1(x_F1) = x_F1 * f(x_F1) + Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
      };


//-------`(aa.)arcsin2`---------------------
//
// Second-order ADAA asin().
//
// The domain of this function is [-1.0, 1.0]; its theoretical range is
// [-π/2.0; π/2.0].
//
// Note that this function is not accurate for low-frequency input signals.
// In that case, the first-order ADAA asin() can be used.
//
// #### Usage
// ```
// _ : aa.arcsin2 : _
// ```
//------------------------------------------
declare arcsin2 author "Dario Sanfilippo";
declare arcsin2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arcsin2 license "MIT License";
arcsin2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = .001;
           f(x_f) = Rasin(x_f);
           F1(x_F1) = x_F1 * f(x_F1) + Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .25 * (Rsqrt(1.0 - x_F2 ^ 2.0) * x_F2 + 
               (2.0 * x_F2 ^ 2.0 - 1.0) * f(x_F2));
      };


//-------`(aa.)tangent`---------------------
//
// First-order ADAA tan().
//
// The domain of this function is [-π/2.0; π/2.0]; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.tangent : _
// ```
//------------------------------------------
declare tangent author "Dario Sanfilippo";
declare tangent copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare tangent license "MIT License";
tangent(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001;
           f(x_f) = Rtan(x_f);
           F1(x_F1) = -1.0 * Rlog(cos(x_F1));
      };


//-------`(aa.)atanh1`---------------------
//
// First-order ADAA atanh(). 
//
// The domain of this function is [-1.0; 1.0]; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.atanh1 : _
// ```
//------------------------------------------
declare atanh1 author "Dario Sanfilippo";
declare atanh1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare atanh1 license "MIT License";
atanh1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = .001;
           f(x_f) = Ratanh(x_f);
           F1(x_F1) = .5 * Rlog(1.0 - x_F1 ^ 2.0) + x_F1 * f(x_F1);
      };


//-------`(aa.)atanh2`---------------------
//
// Second-order ADAA atanh().
//
// The domain of this function is [-1.0; 1.0]; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.atanh2 : _
// ```
//------------------------------------------
declare atanh2 author "Dario Sanfilippo";
declare atanh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare atanh2 license "MIT License";
atanh2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = .001;
           f(x_f) = Ratanh(x_f);
           F1(x_F1) = .5 * Rlog(1.0 - x_F1 ^ 2.0) + x_F1 * f(x_F1);
           F2(x_F2) = .5 * x_F2 ^ 2.0 * f(x_F2) + x_F2 / 2.0 + .25 * 
               Rlog(1.0 - x_F2) - .25 * Rlog(1.0 + x_F2);
      };